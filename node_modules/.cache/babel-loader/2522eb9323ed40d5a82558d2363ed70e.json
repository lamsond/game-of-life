{"ast":null,"code":"import _toConsumableArray from \"/home/conrad/Desktop/game-of-life/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/conrad/Desktop/game-of-life/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/conrad/Desktop/game-of-life/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/conrad/Desktop/game-of-life/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/conrad/Desktop/game-of-life/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/conrad/Desktop/game-of-life/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/home/conrad/Desktop/game-of-life/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nvar _jsxFileName = \"/home/conrad/Desktop/game-of-life/src/Board.js\";\nimport React from 'react';\nimport { Cell } from './Cell.js';\nexport var Board =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Board, _React$Component);\n\n  function Board(props) {\n    var _this;\n\n    _classCallCheck(this, Board);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Board).call(this, props));\n    _this.state = {\n      cells: _this.buildArray(),\n      neighbors: _this.buildArray()\n    };\n    _this.isThereAnybodyOutThere = _this.isThereAnybodyOutThere.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.getNeighborCount = _this.getNeighborCount.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.updateNeighbors = _this.updateNeighbors.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.nextGen = _this.nextGen.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.runGame = _this.runGame.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(Board, [{\n    key: \"buildArray\",\n    value: function buildArray() {\n      //builds a 2D array full of zeros\n      var sq = [];\n      var row = Array(this.props.size).fill(0);\n\n      for (var i = 0; i < this.props.size; i++) {\n        sq.push(row);\n      }\n\n      return sq;\n    }\n  }, {\n    key: \"isThereAnybodyOutThere\",\n    value: function isThereAnybodyOutThere(x, y, val) {\n      /* this is the callback from the cell\n      * it is called when a cell is clicked on\n      * @param x,y grid location\n      * @param val 0 = dead, 1 = alive\n      */\n      var new_arr = [];\n\n      var copy_cells = _toConsumableArray(this.state.cells);\n\n      for (var i = 0; i < copy_cells.length; i++) {\n        // if it is not the row that contains the clicked on cell \n        if (i != x) {\n          // push a copy into the new array\n          new_arr.push(copy_cells[i]);\n        } else {\n          var new_row = [];\n          var old_row = copy_cells[i];\n\n          for (var j = 0; j < copy_cells.length; j++) {\n            // if it is not the clicked on cell\n            if (j != y) {\n              // push whatever was there \n              new_row.push(old_row[j]);\n            } else {\n              // push val returned from the cell\n              new_row.push(val);\n            }\n          } // push the modified row into the new array\n\n\n          new_arr.push(new_row);\n        }\n      } // update state\n\n\n      this.setState({\n        cells: new_arr\n      });\n      this.updateNeighbors();\n    }\n  }, {\n    key: \"updateNeighbors\",\n    value: function updateNeighbors() {\n      /* this method handles populating the neighbor array\n       * with the neighbor counts returned from getNeighborCount\n       */\n      var neighbor_counts = [];\n      var length = this.state.cells.length;\n\n      for (var i = 0; i < length; i++) {\n        var row = [];\n\n        for (var j = 0; j < length; j++) {\n          // push all the neighbor counts into a row\n          row.push(this.getNeighborCount(i, j));\n        } // push the row into the array\n\n\n        neighbor_counts.push(row);\n      } // update state \n\n\n      this.setState({\n        neighbors: neighbor_counts\n      });\n    }\n  }, {\n    key: \"getNeighborCount\",\n    value: function getNeighborCount(i, j) {\n      /* this method handles the math of counting\n       * neighboring cells\n       * @param i, j loctation in grid\n       * @return number of neighbors (0 - 8)\n       */\n      var living_neighbors = 0; // double loop through region bordering cell @i, j\n\n      for (var x = i - 1; x <= i + 1; x++) {\n        for (var y = j - 1; y <= j + 1; y++) {\n          // do not count itself\n          var not_me = !(x == i && y == j); //make sure index is in range (not negative, not exceeding size)\n\n          var in_bounds = x >= 0 && y >= 0 && x < this.props.size && y < this.props.size; // only count if valid index other than itself\n\n          if (not_me && in_bounds) {\n            // add up the 1's (living neighbors)\n            living_neighbors += this.state.cells[x][y];\n          }\n        }\n      }\n\n      return living_neighbors;\n    }\n  }, {\n    key: \"renderCell\",\n    value: function renderCell(i, j) {\n      //renders cell @ grid location i, j\n      var cellWidth = Math.round(this.props.width / this.props.size);\n      return React.createElement(Cell, {\n        width: cellWidth,\n        row_pos: i,\n        col_pos: j,\n        call_back: this.isThereAnybodyOutThere,\n        run: this.props.run,\n        alive: this.state.cells[i][j],\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 129\n        },\n        __self: this\n      });\n    }\n  }, {\n    key: \"renderTable\",\n    value: function renderTable() {\n      // renders table of cells\n      var table = [];\n\n      for (var i = 0; i < this.props.size; i++) {\n        var row = [];\n\n        for (var j = 0; j < this.props.size; j++) {\n          row.push(this.renderCell(i, j));\n        }\n\n        table.push(React.createElement(\"tr\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 149\n          },\n          __self: this\n        }, row));\n      }\n\n      return table;\n    }\n  }, {\n    key: \"nextGen\",\n    value: function nextGen() {\n      /* this method handles all the game of life logic\n       * living cells with less than 2 neighbors die\n       * living cells with 2 or 3 neighbors live\n       * living cells with more than 3 neighbors die\n       * dead cells with exactly 3 neighbors come to life\n       */\n      //only calculate if in 'run' mode\n      if (this.props.run) {\n        var new_arr = [];\n        var length = this.state.cells.length; //loop through both 2D state arrays\n\n        for (var i = 0; i < length; i++) {\n          var new_row = [];\n\n          for (var j = 0; j < length; j++) {\n            // the cell is alive!\n            var alive = this.state.cells[i][j] == 1; // number of neighbors\n\n            var n = this.state.neighbors[i][j]; // the cell will stay alive\n\n            var stay_alive = alive && n > 1 && n <= 3; // the cell will come to life\n\n            var born_again = !alive && n == 3; // push a 1 in if living or reborn\n\n            if (stay_alive || born_again) {\n              new_row.push(1);\n            } // push a 0 for dead cells\n            else {\n                new_row.push(0);\n              }\n          }\n\n          new_arr.push(new_row);\n        } //update state\n\n\n        this.setState({\n          cells: new_arr\n        });\n      }\n    }\n  }, {\n    key: \"runGame\",\n    value: function runGame() {\n      // this is the timer method\n      // only update neighbors if in 'run' mode\n      if (this.props.run) {\n        this.updateNeighbors();\n      } // run game logic\n\n\n      this.nextGen();\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // start the timer when the board first renders\n      this.timerID = setInterval(this.runGame, 1000);\n    }\n  }, {\n    key: \"componentDidUnmount\",\n    value: function componentDidUnmount() {\n      //clear the timer when the board is removed\n      clearInterval(this.timerID);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var tableStyle = {\n        borderWidth: 2,\n        borderStyle: 'solid',\n        borderColor: '#232323',\n        borderRadius: 5,\n        width: this.props.width,\n        margin: 'auto'\n      };\n      return React.createElement(\"table\", {\n        style: tableStyle,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 231\n        },\n        __self: this\n      }, React.createElement(\"tbody\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 231\n        },\n        __self: this\n      }, this.renderTable()));\n    }\n  }]);\n\n  return Board;\n}(React.Component);","map":{"version":3,"sources":["/home/conrad/Desktop/game-of-life/src/Board.js"],"names":["React","Cell","Board","props","state","cells","buildArray","neighbors","isThereAnybodyOutThere","bind","getNeighborCount","updateNeighbors","nextGen","runGame","sq","row","Array","size","fill","i","push","x","y","val","new_arr","copy_cells","length","new_row","old_row","j","setState","neighbor_counts","living_neighbors","not_me","in_bounds","cellWidth","Math","round","width","run","table","renderCell","alive","n","stay_alive","born_again","timerID","setInterval","clearInterval","tableStyle","borderWidth","borderStyle","borderColor","borderRadius","margin","renderTable","Component"],"mappings":"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","sourcesContent":["import React from 'react';\nimport {Cell} from './Cell.js';\n\nexport class Board extends React.Component{\n\t\n\tconstructor(props){\n\t\tsuper(props);\n\n\t\tthis.state = {\n\t\t\tcells: this.buildArray(),\n\t\t\tneighbors: this.buildArray(),\n\t\t};\n\t\n\t\tthis.isThereAnybodyOutThere = this.isThereAnybodyOutThere.bind(this);\n\t\tthis.getNeighborCount = this.getNeighborCount.bind(this);\n\t\tthis.updateNeighbors = this.updateNeighbors.bind(this);\n\t\tthis.nextGen = this.nextGen.bind(this);\n\t\tthis.runGame = this.runGame.bind(this);\n\t}\n\n\tbuildArray(){\n\t\t//builds a 2D array full of zeros\n\t\tlet sq = [];\n\t\tlet row = Array(this.props.size).fill(0);\n\n\t\tfor(let i = 0; i < this.props.size; i++){\n\t\t\tsq.push(row);\n\t\t}\n\n\t\treturn sq;\n\t}\n\n\tisThereAnybodyOutThere(x, y, val){\n\t\t/* this is the callback from the cell\n\t\t* it is called when a cell is clicked on\n\t\t* @param x,y grid location\n\t\t* @param val 0 = dead, 1 = alive\n\t\t*/\n\t\tlet new_arr = [];\n\t\tlet copy_cells = [...this.state.cells];\n\t\t\n\t\tfor(let i = 0; i < copy_cells.length; i++){\n\t\t\t// if it is not the row that contains the clicked on cell \n\t\t\tif(i != x){\n\t\t\t\t// push a copy into the new array\n\t\t\t\tnew_arr.push(copy_cells[i]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlet new_row = [];\n\t\t\t\tlet old_row = copy_cells[i];\n\n\t\t\t\tfor(let j = 0; j < copy_cells.length; j++){\n\t\t\t\t\t// if it is not the clicked on cell\n\t\t\t\t\tif(j != y){\n\t\t\t\t\t\t// push whatever was there \n\t\t\t\t\t\tnew_row.push(old_row[j]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// push val returned from the cell\n\t\t\t\t\t\tnew_row.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// push the modified row into the new array\n\t\t\t\tnew_arr.push(new_row);\n\t\t\t}\n\t\t}\n\n\t\t// update state\n\t\tthis.setState({cells: new_arr});\n\t\tthis.updateNeighbors();\n\t}\n\n\tupdateNeighbors(){\n\t\t/* this method handles populating the neighbor array\n\t\t * with the neighbor counts returned from getNeighborCount\n\t\t */\n\n\t\tlet neighbor_counts = [];\n\t\tlet length = this.state.cells.length;\n\n\t\tfor(let i = 0; i < length; i++){\n\t\t\tlet row = []\n\n\t\t\tfor(let j = 0; j < length; j++){\n\t\t\t\t// push all the neighbor counts into a row\n\t\t\t\trow.push(this.getNeighborCount(i, j));\n\t\t\t}\n\t\t\t// push the row into the array\n\t\t\tneighbor_counts.push(row);\n\t\t}\n\t\t\n\t\t// update state \n\t\tthis.setState({neighbors: neighbor_counts,});\n\t}\n\n\tgetNeighborCount(i, j){\n\t\t/* this method handles the math of counting\n\t\t * neighboring cells\n\t\t * @param i, j loctation in grid\n\t\t * @return number of neighbors (0 - 8)\n\t\t */\n\n\t\tlet living_neighbors = 0;\n\n\t\t// double loop through region bordering cell @i, j\n\t\tfor(let x = i - 1; x <= i + 1; x++){\n\t\t\tfor(let y = j - 1; y <= j + 1; y++){\n\t\t\t\t// do not count itself\n\t\t\t\tlet not_me = !(x==i && y==j);\n\t\t\t\t//make sure index is in range (not negative, not exceeding size)\n\t\t\t\tlet in_bounds = x >= 0 && y >= 0 && x < this.props.size && y < this.props.size;\n\n\t\t\t\t// only count if valid index other than itself\n\t\t\t\tif(not_me && in_bounds){\n\t\t\t\t\t// add up the 1's (living neighbors)\n\t\t\t\t\tliving_neighbors += this.state.cells[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn living_neighbors;\n\t}\n\n\trenderCell(i, j){\n\t\t//renders cell @ grid location i, j\n\t\tlet cellWidth = Math.round(this.props.width/this.props.size);\n\t\t\n\t\treturn (\n\t\t\t<Cell \n\t\t\t\twidth={cellWidth}\n\t\t\t\trow_pos={i}\n\t\t\t\tcol_pos={j}\n\t\t\t\tcall_back={this.isThereAnybodyOutThere}\n\t\t\t\trun={this.props.run}\n\t\t\t\talive={this.state.cells[i][j]}\t\n\t\t\t/>\n\t\t       );\n\t}\n\n\trenderTable(){\n\t\t// renders table of cells\n\t\tlet table = [];\n\n\t\tfor(let i = 0; i < this.props.size; i++){\n\t\t\tlet row = [];\n\t\t\tfor(let j = 0; j < this.props.size; j++){\n\t\t\t\trow.push(this.renderCell(i, j));\n\t\t\t}\n\t\t\ttable.push(<tr>{row}</tr>);\n\t\t}\n\n\t\treturn table;\n\t}\n\n\tnextGen(){\n\t\t/* this method handles all the game of life logic\n\t\t * living cells with less than 2 neighbors die\n\t\t * living cells with 2 or 3 neighbors live\n\t\t * living cells with more than 3 neighbors die\n\t\t * dead cells with exactly 3 neighbors come to life\n\t\t */\n\n\t\t//only calculate if in 'run' mode\n\t\tif(this.props.run){\n\t\t\tlet new_arr = [];\n\t\t\tlet length = this.state.cells.length;\n\n\t\t\t//loop through both 2D state arrays\n\t\t\tfor(let i = 0; i < length; i++){\n\t\t\t\tlet new_row = [];\n\t\t\t\tfor(let j = 0; j < length; j++){\n\n\t\t\t\t\t// the cell is alive!\n\t\t\t\t\tlet alive = (this.state.cells[i][j] == 1);\n\t\t\t\t\t// number of neighbors\n\t\t\t\t\tlet n = this.state.neighbors[i][j];\n\t\t\t\t\t// the cell will stay alive\n\t\t\t\t\tlet stay_alive = (alive && n > 1 && n <= 3);\n\t\t\t\t\t// the cell will come to life\n\t\t\t\t\tlet born_again = (!alive && n == 3);\n\n\t\t\t\t\t// push a 1 in if living or reborn\n\t\t\t\t\tif(stay_alive || born_again){\n\t\t\t \t\t\tnew_row.push(1);\n\t\t\t\t\t}\n\t\t\t\t\t// push a 0 for dead cells\n\t\t\t\t\telse{\n\t\t\t\t\t\tnew_row.push(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnew_arr.push(new_row);\n\t\t\t}\n\t\t\n\t\t\t//update state\n\t\t\tthis.setState({cells: new_arr,});\n\t\t}\n\t}\t\t\n\n\trunGame(){\n\t\t// this is the timer method\n\t\t\n\t\t// only update neighbors if in 'run' mode\n\t\tif(this.props.run){\n\t\t\tthis.updateNeighbors();\n\t\t}\n\t\t// run game logic\n\t\tthis.nextGen();\n\t}\n\n\tcomponentDidMount(){\n\t\t// start the timer when the board first renders\n\t\tthis.timerID = setInterval(this.runGame, 1000);\n\t}\n\n\tcomponentDidUnmount(){\n\t\t//clear the timer when the board is removed\n\t\tclearInterval(this.timerID);\n\t}\n\n\trender(){\n\n\t\tlet tableStyle = {\n\t\t\tborderWidth: 2,\n\t\t\tborderStyle: 'solid',\n\t\t\tborderColor: '#232323',\n\t\t\tborderRadius: 5,\n\t\t\twidth: this.props.width,\n\t\t\tmargin: 'auto',\n\t\t};\n\n\t\treturn (<table style={tableStyle}><tbody>{this.renderTable()}</tbody></table>);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}